var Acl = function() {
    this.ANY = '*';
    this._rules = [];
};

module.exports = function() {
    return new Acl();
};

Acl.prototype.middleware = function() {
    return function(req, res, next) {
        var err;
        if(req.user && req.user.role) {
            if(this.isAllowed(req.user.role, req.pathname, req.method)) {
                return next();
            } else {
                err = new Error('User is not authorized');
                err.status = 403;
            }
        } else {
            err = new Error('User must authenticate');
            err.status = 401;
        }
        return next(err);
    }.bind(this);
};

/**
 * Add a new rule, starting with the resource + action to match
 * @param resource
 * @param actions
 * @returns {{thenOnlyAllow: thenOnlyAllow}}
 */
Acl.prototype.match = function(resource, actions) {

    function argsAreStrings(args) {
        
        if(Array.isArray(args[0])) {
            args = args[0];
        }
        
        return Array.prototype.slice.call(args).every(function(val) {
            return typeof val === 'string';
        });
    }

    //validate
    if(typeof resource === 'string') {
        resource = new RegExp('^' + resource.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") + '$');
    }
    
    //normalize
    if(!(resource instanceof RegExp)) {
        throw new Error('Cannot do acl match, resources must be a string or regex');
    }

    return {
        for: function(actions) {
            //validate
            if(!Array.isArray(actions) && !argsAreStrings(arguments)) {
                throw new Error('Cannot add acl rule, actions must be strings or an array');
            }

            //normalize
            if(!Array.isArray(actions)) {
                actions = Array.prototype.slice.call(arguments);
            }

            return {
                thenAllow: function(roles) {
                    //validate
                    if(!Array.isArray(roles) && !argsAreStrings(arguments)) {
                        throw new Error('Cannot add acl rule, roles must be strings or an array');
                    }

                    //normalize
                    if(!Array.isArray(roles)) {
                        roles = Array.prototype.slice.call(arguments);
                    }

                    //find existing rule
                    var rule = this._rules.filter(function (rule) {
                            return rule.resource.source === resource.source &&
                                rule.actions.sort().toString() === actions.sort().toString();
                        })[0] || { _new: true };

                    //create or update
                    rule.resource = resource;
                    rule.actions = actions;
                    rule.roles = roles;

                    //add if new
                    if(rule._new) {
                        delete rule._new;
                        this._rules.push(rule);
                    }

                    return this;
                }.bind(this)
            }
        }.bind(this)
    };
};

/**
 * Loops through the acls in order added looking for a resource pattern match.
 * Grants permission if the role is found
 * @param role
 * @param resource
 * @param action
 * @returns {boolean}
 */
Acl.prototype.isAllowed = function(role, resource, action) {

    //check args
    var argNames = [ 'role', 'resource', 'action'];
    for(i = 0; i < argNames.length; i++) {
        if(typeof arguments[i] !== 'string') {
            throw new Error('Can\'t check permission with this ' + argNames[i] + 
                            '. It should be a string, but it is a: ' + typeof argNames[i]);
        }    
    }
    
    //test rules in reverse order. last defined have highest priority
    var i, rule;
    for(i = this._rules.length - 1; i >= 0; i--) {
        rule = this._rules[i];

        //test if regex
        var matchResource = rule.resource.test(resource);

        //string star will match any otherwise find match in actions array
        var matchAction = action === this.ANY || rule.actions.indexOf(action) > -1;

        //if the resource + action is match then allow or deny, given the role
        if(matchResource && matchAction) {
            var matchRole = rule.roles.indexOf(this.ANY) > -1 || rule.roles.indexOf(role) > -1;
            return matchRole;
        }
    }

    //deny by default
    return false;
};

/**
 * Serializes this ACL instance
 */
Acl.prototype.toJSON = function() {

    //temp patch regex tojson method
    var orignalRegexToJson = RegExp.prototype.toJSON;
    RegExp.prototype.toJSON = RegExp.prototype.toString;

    var serialized = JSON.stringify(this._rules);
    RegExp.prototype.toJSON = orignalRegexToJson;
    return serialized;
};

/**
 * Deserializes from JSON that was generated by toJSON
 * @param rules
 */
Acl.prototype.fromJSON = function(rules) {
    
    rules = JSON.parse(rules);

    var isRegexPattern = new RegExp('^\/(.*)\/$');
    rules = rules.map(function (rule) {
        var regex = isRegexPattern.exec(rule.resource);
        rule.resource = new RegExp(regex[1]);
        return rule;
    });

    this._rules = rules;
}

/**
 * Clear all rules
 */
Acl.prototype.reset = function () {
    this._rules = [];
};